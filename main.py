# -*- coding: utf-8 -*-
"""unet_neuoral_membranse.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wKEM-_wPt1996OYfWf7qyIDhZDM5fawk
"""
import torch
import torch.nn.functional as F
from torch.utils.data import DataLoader
from torchvision.utils import make_grid
import matplotlib.pyplot as plt

import numpy as np 
import cv2 as cv

import re
import glob

from unet import UNet

#%% 
def Normalize(img):
    return np.array(img/255.0, dtype=np.float32)
  
def Numerical_Sort(value):
    numbers = re.compile(r'(\d+)')
    parts = numbers.split(value)
    parts[1::2] = map(int, parts[1::2])
    return parts

def Read_Images_Train(folder_path, image_names):
    images = []
    for filename in sorted(glob.glob(folder_path), key=Numerical_Sort):
        image_names.append(filename.split('/')[-1])
        img = cv.imread(filename, flags = cv.IMREAD_GRAYSCALE)
        images.append(Normalize(img))
    
    images = np.asarray(images, dtype=np.float32)
    images = images[:, :, :, np.newaxis, np.newaxis]    # format => [N, H, W, C]
    return images

def Read_Images_Test(folder_path, image_names):
    images = []
    for filename in sorted(glob.glob(folder_path), key=Numerical_Sort):
        image_names.append(filename.split('/')[-1])
        img = cv.imread(filename, flags = cv.IMREAD_GRAYSCALE)
        img = cv.resize(img, (324,324), interpolation = cv.INTER_AREA)
        images.append(Normalize(img))
    
    images = np.asarray(images, dtype=np.float32)
    images = images[:, :, :, np.newaxis, np.newaxis]    # format => [N, H, W, C]
    return images

def matplotlib_imshow(img, one_channel=False):
    npimg = img.cpu().numpy()
    np.interp(npimg, (npimg.min(), npimg.max()), (0, 255))
    if one_channel:
        plt.imshow(np.transpose(npimg, (1, 2, 0)))
    else:
        plt.imshow(np.transpose(npimg, (1, 2, 0)))

#%% dataset load and preprocessing

drive_path = "./data" 

test_images_path = drive_path + "/test/*.tif"

train_gtruth_path = drive_path + "/train/labels/*.tif"
train_images_path = drive_path + "/train/images/*.tif"

test_images = []
image_names = []
train_gtruth = []
train_images = []
test_images = Read_Images_Train(test_images_path, image_names)
train_images = Read_Images_Train(train_images_path, image_names)    
train_gtruth = Read_Images_Test(train_gtruth_path, image_names)

#%%
# Create data loaders.

device = 'cuda' if torch.cuda.is_available() else 'cpu'
print(f'Using {device} device')

# pytorch input format => [N, H, W, C1, C2] -> [N, C1, C2, H, W]
test_tensor = torch.from_numpy(test_images).transpose_(3 , 1).transpose_(4 , 2).float().to(device)
train_tensor = torch.from_numpy(train_images).transpose_(3 , 1).transpose_(4 , 2).float().to(device)
train_gtruth_tensor = torch.from_numpy(train_gtruth).transpose_(3 , 1).transpose_(4 , 2).float().to(device)

test_dl = DataLoader(test_tensor, batch_size=10, shuffle=False)
train_dl = DataLoader(train_tensor, batch_size=10, shuffle=False)
train_gtruth_dl = DataLoader(train_gtruth_tensor, batch_size=10, shuffle=False)

train_iter = next(iter(train_dl))
train_gtruth_iter = next(iter(train_gtruth_dl))
test_iter = next(iter(test_dl))
#%%

model = UNet().to(device)
print(model)
optim = torch.optim.Adam(model.parameters(), lr = 0.001)
epoch = 10

#%%

for _ in range(epoch):
    for i in range(len(train_iter)):
        optim.zero_grad()
        prediction = model(train_iter[i])
        loss = F.mse_loss(prediction, train_gtruth_iter[i])
        loss.backward()
        optim.step()
        print(loss)

print('Finished Training')

test_prediction = model(test_iter[0])
img_grid = make_grid(test_prediction)

# show images
matplotlib_imshow(img_grid, one_channel=True)

#%% model save

torch.save(model.state_dict(), "model.pth")
print("Saved PyTorch Model State to model.pth")

#%%
# model load
model_test = UNet().to(device)
model_test.load_state_dict(torch.load("model.pth"))

test_prediction = model_test(test_iter[0])
img_grid = make_grid(test_prediction)

# show images
matplotlib_imshow(img_grid, one_channel=True)
print(5)